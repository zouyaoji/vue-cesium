{"version":3,"file":"AxisAlignedBoundingBox-574d1269.js","sources":["../../../../Source/Core/AxisAlignedBoundingBox.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Intersect from \"./Intersect.js\";\n\n/**\n * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.\n * @alias AxisAlignedBoundingBox\n * @constructor\n *\n * @param {Cartesian3} [minimum=Cartesian3.ZERO] The minimum point along the x, y, and z axes.\n * @param {Cartesian3} [maximum=Cartesian3.ZERO] The maximum point along the x, y, and z axes.\n * @param {Cartesian3} [center] The center of the box; automatically computed if not supplied.\n *\n * @see BoundingSphere\n * @see BoundingRectangle\n */\nfunction AxisAlignedBoundingBox(minimum, maximum, center) {\n  /**\n   * The minimum point defining the bounding box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.minimum = Cartesian3.clone(defaultValue(minimum, Cartesian3.ZERO));\n\n  /**\n   * The maximum point defining the bounding box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.maximum = Cartesian3.clone(defaultValue(maximum, Cartesian3.ZERO));\n\n  //If center was not defined, compute it.\n  if (!defined(center)) {\n    center = Cartesian3.midpoint(this.minimum, this.maximum, new Cartesian3());\n  } else {\n    center = Cartesian3.clone(center);\n  }\n\n  /**\n   * The center point of the bounding box.\n   * @type {Cartesian3}\n   */\n  this.center = center;\n}\n\n/**\n * Computes an instance of an AxisAlignedBoundingBox. The box is determined by\n * finding the points spaced the farthest apart on the x, y, and z axes.\n *\n * @param {Cartesian3[]} positions List of points that the bounding box will enclose.  Each point must have a <code>x</code>, <code>y</code>, and <code>z</code> properties.\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\n *\n * @example\n * // Compute an axis aligned bounding box enclosing two points.\n * var box = Cesium.AxisAlignedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\n */\nAxisAlignedBoundingBox.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new AxisAlignedBoundingBox();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.minimum = Cartesian3.clone(Cartesian3.ZERO, result.minimum);\n    result.maximum = Cartesian3.clone(Cartesian3.ZERO, result.maximum);\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    return result;\n  }\n\n  var minimumX = positions[0].x;\n  var minimumY = positions[0].y;\n  var minimumZ = positions[0].z;\n\n  var maximumX = positions[0].x;\n  var maximumY = positions[0].y;\n  var maximumZ = positions[0].z;\n\n  var length = positions.length;\n  for (var i = 1; i < length; i++) {\n    var p = positions[i];\n    var x = p.x;\n    var y = p.y;\n    var z = p.z;\n\n    minimumX = Math.min(x, minimumX);\n    maximumX = Math.max(x, maximumX);\n    minimumY = Math.min(y, minimumY);\n    maximumY = Math.max(y, maximumY);\n    minimumZ = Math.min(z, minimumZ);\n    maximumZ = Math.max(z, maximumZ);\n  }\n\n  var minimum = result.minimum;\n  minimum.x = minimumX;\n  minimum.y = minimumY;\n  minimum.z = minimumZ;\n\n  var maximum = result.maximum;\n  maximum.x = maximumX;\n  maximum.y = maximumY;\n  maximum.z = maximumZ;\n\n  result.center = Cartesian3.midpoint(minimum, maximum, result.center);\n\n  return result;\n};\n\n/**\n * Duplicates a AxisAlignedBoundingBox instance.\n *\n * @param {AxisAlignedBoundingBox} box The bounding box to duplicate.\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\n */\nAxisAlignedBoundingBox.clone = function (box, result) {\n  if (!defined(box)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new AxisAlignedBoundingBox(box.minimum, box.maximum, box.center);\n  }\n\n  result.minimum = Cartesian3.clone(box.minimum, result.minimum);\n  result.maximum = Cartesian3.clone(box.maximum, result.maximum);\n  result.center = Cartesian3.clone(box.center, result.center);\n  return result;\n};\n\n/**\n * Compares the provided AxisAlignedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {AxisAlignedBoundingBox} [left] The first AxisAlignedBoundingBox.\n * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nAxisAlignedBoundingBox.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Cartesian3.equals(left.center, right.center) &&\n      Cartesian3.equals(left.minimum, right.minimum) &&\n      Cartesian3.equals(left.maximum, right.maximum))\n  );\n};\n\nvar intersectScratch = new Cartesian3();\n/**\n * Determines which side of a plane a box is located.\n *\n * @param {AxisAlignedBoundingBox} box The bounding box to test.\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nAxisAlignedBoundingBox.intersectPlane = function (box, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"box\", box);\n  Check.defined(\"plane\", plane);\n  //>>includeEnd('debug');\n\n  intersectScratch = Cartesian3.subtract(\n    box.maximum,\n    box.minimum,\n    intersectScratch\n  );\n  var h = Cartesian3.multiplyByScalar(intersectScratch, 0.5, intersectScratch); //The positive half diagonal\n  var normal = plane.normal;\n  var e =\n    h.x * Math.abs(normal.x) +\n    h.y * Math.abs(normal.y) +\n    h.z * Math.abs(normal.z);\n  var s = Cartesian3.dot(box.center, normal) + plane.distance; //signed distance from center\n\n  if (s - e > 0) {\n    return Intersect.INSIDE;\n  }\n\n  if (s + e < 0) {\n    //Not in front because normals point inward\n    return Intersect.OUTSIDE;\n  }\n\n  return Intersect.INTERSECTING;\n};\n\n/**\n * Duplicates this AxisAlignedBoundingBox instance.\n *\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\n */\nAxisAlignedBoundingBox.prototype.clone = function (result) {\n  return AxisAlignedBoundingBox.clone(this, result);\n};\n\n/**\n * Determines which side of a plane this box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nAxisAlignedBoundingBox.prototype.intersectPlane = function (plane) {\n  return AxisAlignedBoundingBox.intersectPlane(this, plane);\n};\n\n/**\n * Compares this AxisAlignedBoundingBox against the provided AxisAlignedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {AxisAlignedBoundingBox} [right] The right hand side AxisAlignedBoundingBox.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nAxisAlignedBoundingBox.prototype.equals = function (right) {\n  return AxisAlignedBoundingBox.equals(this, right);\n};\nexport default AxisAlignedBoundingBox;\n"],"names":["Cartesian3","defaultValue","defined","Check","Intersect"],"mappings":"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"}